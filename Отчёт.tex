\documentclass[a4paper,14pt]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\renewcommand{\baselinestretch}{1.5}

\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\begin{document}

\section*{Аннотация}

Цель работы — создание инструментов для автоматического написания программ с
помощью генетических алгоритмов.

Современные программы не изменяют сами себя. Практически весь процесс создания
ПО привязан к человеку-разработчику. Однако наблюдение за живой природой
показывают нам, что объект может динамически саморазвиваться, чтобы лучше
соответствовать внешним условиям и поставленным перед ним целям.

Органическая жизнь саморазвивается с помощью эволюции, биологической реализации
генетических алгоритмов. Они активно применяются в информационных технологиях и
изучены на достаточном уровне, чтобы применить их для саморазвития алгоритмов
программного обеспечения.

В основе генетических алгоритмов лежат случайные изменения, смешивания и отбор.
К сожалению, реализация первых двух действий для исходного или машинного кода 
программ неэффективна. Поэтому выгодно представить алгоритм в более удобном
виде.

В данной работе будут рассмотрены существующие способы эволюции алгоритмов и
показан новый способ, более эффективный для представленных целей.

\newpage
\tableofcontents

\newpage
\section{Актуальность темы}

\subsection{Авто-написание программы}
Для того, чтобы программа была автоматически написана, разработчик должен
описать требования к ней в виде оценочной функции. К сожалению, для большинства
бытовых задач, написание подходящей оценочной функции сложнее, чем
разработка самой программы.

Но есть области информационных технологий, где создание программы невероятно
сложно, а описание требований к ней — простое:
\begin{itemize}
  \item Программирование сложных систем, состоящих из автономных объектов
        взаимодействующих друг с другом. Например, группировка относительно
        простых спутников. Такие сложные системы очень надёжны (выход одного
        элемента лишь немного уменьшает мощность множества) и эффективны (из-за
        параллельной работы).
  \item Поиск оптимальных стратегий, который востребован теорией игр,
        макроэкономикой и эволюционной биологией.\cite{communication}
\end{itemize}

Поиск решений для данных задач довольно трудоёмок и сейчас слишком похож на
метод проб и ошибок. Например, чтобы найти оптимальную стратегию в Повторяющейся
дилемме заключённого, её автор, Роберт Аксельрод, просто пригласил знакомых
коллег со всего мира предложить своё решение и выбрал лучшее.\cite{dilemma}

Автоматическая разработка программ способна заменить человека в этом сложном,
долгом и не интересном поиске.

Поскольку сложные системы, теория игр, макроэкономика и эволюционная биология
являются очень востребованными областями науки, то и инструмент для них будет
очень актуален.

\subsection{Саморазвитие программы}
В данный момент изменения в алгоритм программы вносит её разработчик. Тогда,
когда это экономически неоправданно или невозможно, алгоритм делают зависимым
от констант и конечные пользователи или автоматика меняют эти настройки.

Однако, параметры статически заданного алгоритма не могут дать полную гибкость,
что бывает нередко нужно. Например, спамеры постоянно экспериментируют и нередко
обходят защиту спам-фильтров, в итоге программистам снова приходится
анализировать методы новой массовой рекламы и переписывать алгоритмы защиты.

Саморазвитие программ будет очень актуально для:
\begin{itemize}
  \item Защиты от спама, чтобы автоматически подстраиваться под новые уловки,
        когда пользователь отмечает письмо как рекламное.
  \item Алгоритмов противника в компьютерных играх, чтобы подстраиваться под
        способности и навыки игрока.
  \item Автоматических роботов, чтобы изменять программу управления при
        поломках и других непредвиденных ситуациях.\cite{damage} Это особенно
        полезно в областях, где человек не может прийти ему на помощь, а связь
        затрудненна, например, в космосе.
\end{itemize}

\newpage
\section{Постановка задачи}
Разработчик формулирует требование к алгоритму $a$ в виде оценочной
функции $T$, так чтобы более подходящий для задачи алгоритм давал больший
результат $T(a)$. Разработчик также предоставляет функцию останова $F$, такую,
что $F(T(a))$ вернёт 1, если алгоритм $a$ полностью подходит и цель разработки
достигнута.

Цель данной работы, предоставить функцию $G(T, F) = a$, которая вернёт алгоритм подходящий разработчику.

Важным требованием в работе является то, чтобы итоговый алгоритм был понятен
человеку и весь процесс его генерации можно было наглядно представить и
анализировать.

\newpage
\section{Генетические алгоритмы}
Как мы видим, задача сводится к оптимизации функции $T(a)$. Однако характер этой
функции неизвестен. Для подобных задач оптимизации весьма эффективны
генетические алгоритмы.\cite{reinforcement}

Генетический алгоритм $G_{ga}$ работает сразу с множеством кандидатов на решение
(популяцией) $A = [a_1, a_2, …, a_n]$. Это итерационный процесс и каждый шаг
$A_i = G_{ga}(A_{i-1})$ немного улучшает оценочную функцию (за значение
оценочной функции популяции, принимается оценочная функция лучшего члена
популяции).

Каждая итерация $G_{ga}(A) = S(Mi(Mu(R(A))))$ состоит из
операций:\cite{reinforcement}
\begin{enumerate}
  \item Размножения $R(A)$ — увеличения популяции простым копированием.
        Поскольку последующий отбор уменьшит популяцию, размножение поддерживает
        её размер на каждом шаге.
  \item Мутации $Mu(A)$ — случайного изменения элементов.
  \item Смешивания $Mi(A)$ — объединения двух элементов со случайным выбором
        частей из каждой половины.
  \item Отбора $S(A)$ — удаление наименее подходящих кандидатов. Для этого для
        каждого элемента популяции вычисляется оценочная функция и элементы с
        наименьшим её значением изымаются из множества.
\end{enumerate}

В конце каждой итерации с помощью функции отбора $F(A)$, которую задаёт
разработчик, определяется нужно ли остановить цикл.

\newpage
\section{Анализ проблемы}
В данным момент, при создании программы, разработчики представляют алгоритм в
виде иерархического дерева команд на одном из множества языков программирования.
Компилятор транслирует исходный текст в машинный код — список команд с условными
переходами.

К сожалению, необходимые для генетического алгоритма мутация и смешивание очень
трудоёмко реализовать для типа данных в виде дерева или списка с переходами.
Поскольку современные языки программирования и машинных код — это не
единственный способ представить алгоритм, то выгоднее представить его в другом,
более эффективном для задачи виде.

\newpage
\section{Обзор решений}

\subsection{Нейронная сеть}
В исследованиях эволюции\cite{communication} довольно часто поведение объекта 
кодируют с помощью нейронной сети:\cite{neural}
\begin{itemize}
  \item Обработка происходит в множестве простых элементов, нейронов.
  \item Сигналы передаются между нейронами через связи.
  \item Каждая связь характеризуется весом, в зависимости от знака которой
        передаваемый сигнал увеличивается или уменьшается.
  \item Каждому нейрону соответствует активационная функция, которая определяет 
        зависимость выходного сигнала от комбинации входящих сигналов.
\end{itemize}

Несмотря на то, что элементы нейронной сети имеют очень ограниченные
вычислительные способности, вся сеть в целом, объединяя большое число таких
элементов, оказывается способной выполнять весьма сложные задачи.

Нейронная сеть представляется в виде матрицы весов $X$, так что элемент
$x_{ij}$ соответствует весу связи от нейрона $i$ к нейрону $j$. Мутация
вносит случайные изменения в веса и, с небольшой вероятностью, добавляет или
удаляет новый нейрон. Смешивание либо усредняет веса между двумя матрицами, либо
случайным образом выбирает ячейки из матриц-«родителей».

К сожалению, человек не может понять алгоритм нейронной сети при беглом взгляде
на матрицу или граф, что требуется в поставленной задаче.

\subsection{Конечные автоматы}
В рамках развития идей А. А. Шалыто автоматного программирования рассматривается
генерация конечного автомата с помощью генетических алгоритмов.\cite{shalyto}

Конечный автомат характеризуется множеством состояний и матрицей переходов $X$,
где $x_{ji}$ содержит дискретный код условия при котором автомат перейдёт из
состояний $i$ в состояние $j$.

Матрица состояний преобразуется в битовую строку, с которой генетический
алгоритм и работает: мутация случайно изменяет биты, смешивание объединяет две
строки в одну, случайно выбрав символы из каждой.

К сожалению, автоматы в поставленной задаче имеют недостатков:
\begin{itemize}
  \item Они не полны по Тьюрингу, что несколько ограничивает их гибкость.
  \item Чтобы быть понятными разработчику их надо представить в виде графа, а
        работа с графикой сложнее, чем с обычным текстом.
\end{itemize}

\newpage
\section{Список литературы}

\renewcommand*{\refname}{}
\begin{thebibliography}{}

  \bibitem{communication}
    Mitri, S., Hubert, J. and Waibel, M. Social Behavior: From Cooperation to
    Language. — Biological Theory. 2008. — с. 99—102

  \bibitem{dilemma}
    Axelrod R. The Evolution of Cooperation. — Basic Books, 1984

  \bibitem{damage}
    Bongard J., Lipson H. Automated Damage Diagnosis and Recovery for Remote
    Robotics. — ICRA04, 2004

  \bibitem{reinforcement}
    Sutton R., Barto A. Reinforcement Learning. — The MIT Press, 2002

  \bibitem{neural}
    Haykin S. Neural Networks: A Comprehensive Foundation. 2nd Edition. -- M.: Prentice Hall, 1998

  \bibitem{shalyto}
    Царев Ф.Н., Шалыто А.А. Применение генетического программирования для
    построения автоматов, управляющих системами со сложным поведением. — 2007

\end{thebibliography}

\end{document}

\documentclass[russian,utf8]{eskdtext}
\usepackage{eskdplain}

\setcounter{tocdepth}{2}

\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\begin{document}

\tableofcontents

\newpage
\section{Актуальность темы}

\subsection{Авто-написание программы}

Для того, чтобы программа была автоматически написана, разработчик должен
описать требования к ней в виде оценочной функции. К сожалению, для большинства
бытовых задач, написание подходящей оценочной функции сложнее, чем
разработка самой программы.

Но есть области информационных технологий, где создание программы невероятно
сложно, а описание требований к ней — относительно простое:
\begin{itemize}
  \item Программирование сложных систем, состоящих из автономных объектов
        взаимодействующих друг с другом. Например, группировка простых
        спутников. Такие сложные системы очень надёжны (выход одного элемента
        лишь немного уменьшает мощность множества) и эффективны (из-за
        параллельной работы).
  \item Поиск оптимальных стратегий для теории игр, макроэкономики и
        эволюционной биологии.\cite{communication}
\end{itemize}

Поиск решений для данных задач довольно трудоёмок и сейчас слишком похож на
метод проб и ошибок. Например, чтобы найти оптимальную стратегию в Повторяющейся
дилемме заключённого, её автор, Роберт Аксельрод, просто пригласил знакомых
коллег со всего мира предложить своё решение и выбрал лучшее.\cite{dilemma}

Автоматическая разработка программ способна заменить человека в этом сложном,
долгом и не интересном поиске.

Поскольку сложные системы, теория игр, макроэкономика и эволюционная биология
являются очень востребованными областями науки, то и инструмент для них будет
очень актуален.

\subsection{Саморазвитие программы}

В данный момент изменения в алгоритм программы вносит её разработчик. Тогда,
когда это экономически неоправданно или невозможно, алгоритм делают зависимым
от констант и конечные пользователи или автоматика меняют эти настройки.

Однако, параметры статически заданного алгоритма не могут дать полную гибкость,
что бывает нередко нужно. Например, спамеры постоянно экспериментируют и нередко
обходят защиту спам-фильтров, в итоге программистам снова приходится
анализировать новые методы массовой рекламы и переписывать алгоритмы защиты.

Саморазвитие программ будет очень актуально для:
\begin{itemize}
  \item Защиты от спама, чтобы автоматически подстраиваться под новые уловки,
        когда пользователь отмечает письмо как рекламное.
  \item Алгоритмов противника в компьютерных играх, чтобы подстраиваться под
        способности и навыки игрока.
  \item Автоматических роботов, чтобы изменять программу управления при
        поломках и других непредвиденных ситуациях.\cite{damage} Это особенно
        полезно в областях, где человек не может прийти ему на помощь, а связь
        затрудненна, например, в космосе.
\end{itemize}

\section{Постановка задачи}
Разработчик формулирует требование к алгоритму $a$ в виде оценочной
функции $T$, так чтобы более подходящий для задачи алгоритм давал больший
результат $T(a)$. Разработчик также предоставляет функцию останова $F$, такую,
что $F(T(a))$ вернёт 1, если алгоритм $a$ полностью подходит и цель разработки
достигнута.

Цель данной работы, предоставить инструментарий для разработчика, реализующий
операцию $G(T, F) = a$, которая генерирует алгоритм $a$, получающий максимальное
значение в оценочной функции $T$ и удовлетворяющий критерию останова $F$.

Инструментарий будет использоваться для изучения генетических алгоритмов, так
что важно, чтобы итоговый алгоритм был понятен человеку и весь процесс его
генерации можно было наглядно представить и проанализировать.

\section{Генетические алгоритмы}

Как мы видим, задача сводится к оптимизации функции $T(a)$. Однако характер этой
функции неизвестен. Для подобных задач оптимизации весьма эффективны
генетические алгоритмы.\cite{reinforcement}

Генетический алгоритм $G_{ga}$ работает сразу с множеством кандидатов на решение
(популяцией) $A = [a_1, a_2, …, a_n]$. Это итерационный процесс и каждый шаг
$A_i = G_{ga}(A_{i-1})$ немного улучшает оценочную функцию (за значение
оценочной функции популяции, принимается оценочная функция лучшего члена
популяции).

Каждая итерация $G_{ga}(A) = S(Mi(Mu(R(A))))$ состоит из
операций:\cite{reinforcement}
\begin{enumerate}
  \item Размножения $R(A)$ — увеличения популяции простым копированием.
        Поскольку последующий отбор уменьшит популяцию, размножение поддерживает
        её размер на каждом шаге.
  \item Мутации $Mu(A)$ — случайного изменения элементов.
  \item Смешивания $Mi(A)$ — объединения двух элементов со случайным выбором
        частей из каждой половины.
  \item Отбора $S(A)$ — удаление наименее подходящих кандидатов: для каждого
        элемента популяции вычисляется оценочная функция и элементы с
        наименьшим её значением изымаются из множества.
\end{enumerate}

В конце каждой итерации с помощью функции останова $F(A)$, которую задаёт
разработчик, определяется нужно ли остановить цикл.

\section{Анализ проблемы}

В данным момент, при создании программы, разработчики представляют алгоритм в
виде иерархического дерева команд на одном из множества языков программирования.
Компилятор транслирует исходный текст в машинный код — список команд с условными
переходами.

К сожалению, необходимые для генетического алгоритма мутация и смешивание очень
трудоёмко реализовать для типа данных в виде дерева или списка с переходами.
Поскольку современные языки программирования и машинных код — это не
единственный способ представить алгоритм, то выгоднее представить его в другом,
более эффективном для задачи виде.

\section{Обзор имеющихся решений}

\subsection{Нейронная сеть}

В исследованиях эволюции\cite{communication} довольно часто поведение объекта 
кодируют с помощью нейронной сети:\cite{neural}
\begin{itemize}
  \item Обработка происходит в множестве простых элементов, нейронов.
  \item Сигналы передаются между нейронами через связи.
  \item Каждая связь характеризуется весом, в зависимости от знака которой
        передаваемый сигнал увеличивается или уменьшается.
  \item Каждому нейрону соответствует активационная функция, которая определяет 
        зависимость выходного сигнала от комбинации входящих сигналов.
\end{itemize}

Несмотря на то, что элементы нейронной сети имеют очень ограниченные
вычислительные способности, вся сеть в целом, объединяя большое число таких
элементов, оказывается способной выполнять весьма сложные задачи.

Нейронная сеть представляется в виде матрицы весов $X$, так что элемент
$x_{ij}$ соответствует весу связи от нейрона $i$ к нейрону $j$. Мутация
вносит случайные изменения в веса и, с небольшой вероятностью, добавляет или
удаляет новый нейрон. Смешивание либо усредняет веса между двумя матрицами, либо
случайным образом выбирает ячейки из матриц-«родителей».

К сожалению, человек не может понять алгоритм нейронной сети при беглом взгляде
на матрицу или граф, что требуется в поставленной задаче.

\subsection{Конечные автоматы}

В рамках развития идей А. А. Шалыто о автоматном программировании
рассматривается генерация конечного автомата с помощью генетических
алгоритмов.\cite{shalyto}

Конечный автомат характеризуется множеством состояний и матрицей переходов $X$,
где $x_{ji}$ содержит дискретный код условия при котором автомат перейдёт из
состояний $i$ в состояние $j$.

Матрица состояний преобразуется в битовую строку, с которой генетический
алгоритм и работает: мутация случайно изменяет биты, смешивание объединяет две
строки в одну, случайно выбрав символы из каждой.

К сожалению, для поставленной задачи автоматы имеют ряд недостатков:
\begin{itemize}
  \item Они не полны по Тьюрингу, что несколько ограничивает их гибкость.
  \item Чтобы быть понятными разработчику их надо представить в виде графа, а
        работа с графикой сложнее, чем с обычным текстом.
\end{itemize}

\section{Обзор языка $D^2NA$}

\subsection{Анализ}

Поскольку целью работы является создания понятного и удобного представления
алгоритма для человека, то за основу возьмём современный высокоуровневый язык
программирования.

Первая проблема, которая усложняет случайные изменения в алгоритме —
иерархичность. Уберём её, представив программу в виде набора
условных операторов (\texttt{if}) внутри одного большого постоянного цикла
(\texttt{while}):

\begin{verbatim}
while (true) {
  if (…) {
    …
  }
  if (…) {
    …
  }
}
\end{verbatim}

Будем создавать \texttt{if}-оператор для каждого возможного условия. Чтобы
условных операторов было слишком много, ограничим возможные условия проверки:
\begin{itemize}
  \item поступление внешнего сигнала;
  \item переменная имеет значение больше нуля;
\end{itemize}

\begin{verbatim}
while (true) {
  if (on_siganl('Input')) {
    …
  }
  if (on_siganl('Input') && a > 0) {
    …
  }
  if (a > 0) {
    …
  }
}
\end{verbatim}

Чтобы упростить внесение случайных изменений, уменьшим количество возможных
команд:
\begin{itemize}
  \item увеличение переменой на единицу;
  \item уменьшение переменой на единицу;
  \item отправка исходящего сигнала;
\end{itemize}

\begin{verbatim}
while (true) {
  if (on_siganl('Input')) {
    a += 1;
  }
  if (on_siganl('Input') && a > 0) {
    send('Output');
    a -= 1;
    a -= 1;
  }
  if (a > 0) { }
}
\end{verbatim}

\subsection{Описания языка}

В рамках данной работы был создан особый язык программирования $D^2NA$.

Программа на $D^2NA$ с внешним миром общается с помощью входящих и исходящих
сигналов. Они характеризуются только именем и не имеют параметров и
продолжительности. Количество и имена сигналов напрямую зависят от задачи и
задаются разработчиком. Имя сигнала должно начинаться с двоеточия и заглавной
буквы и может состоять из букв, цифр и знака подчёркивания (например,
\texttt{:Input}).

Существует особый сигнал \texttt{:Init}, которые посылается в программу при её
запуске. Он является своего рода конструктором.

Программа может хранить внутреннее состояние в знаковых целочисленных
переменных. Генератор может автоматически добавлять или удалять их. Имя
переменной должно начинаться с двоеточия и прописной буквы и может состоять из
букв, цифр и знака подчёркивания (например, \texttt{:a}).

Программа состоит из списка правил. Правило характеризуется условием выполнения
и списком команд (правило можно представить в виде оператора if). Условие может
быть двух видов: поступление определённого сигнала и значение определённой
переменной больше 0. Поскольку имена сигналов и переменных отличаются и для
них возможна только одна проверка, то условие записывается как \texttt{on} с
последующими именами сигналов или переменных, разделёнными запятыми (например,
\texttt{on~:Input, :a}).

Команды в правиле будут выполнены только если все проверки условия будут
истинными. Команды записываются между \texttt{do} и \texttt{end} и могут быть
трёх видов: послать исходящий сигнал (\texttt{send X}), увеличить
(\texttt{up x}) или уменьшить (\texttt{down x}) значение переменной.

\subsection{Пример программы на $D^2NA$}
\begin{verbatim}
on :Init do
  up :ping
end

on :Print, :ping do
  send :Ping
  down :ping
  up :pong
end

on :Print, :pong do
  send :Pong
  down :pong
  up :ping
end
\end{verbatim}

Данная простая программа посылает поочерёдно \texttt{:Ping} или \texttt{:Pong}
при каждом входящем сигнале \texttt{:Print}. Чтобы помнить, какой сигнал нужно
послать следующим используются две переменные \texttt{:ping} и \texttt{:pong}.

При запуске программы (при системном сигнале \texttt{:Init}) переменная
\texttt{:ping} увеличивается до значения 1. Далее, когда пришёл сигнал
\texttt{:Print} и значение \texttt{:ping} больше нуля, посылается сигнал
\texttt{:Ping}, \texttt{:ping} уменьшается до 0, а \texttt{:pong}, наоборот,
увеличивается до 1.

При сигнале \texttt{:Print} и положительном значении \texttt{:pong}, посылается
сигнал \texttt{:Pong} и происходит обратная процедура.

\subsection{Генерация программы на $D^2NA$}
Программа на $D^2NA$ представляет из себя просто список списков, которые
генетическому алгоритму удобно смешивать и переставлять.

Мутация добавляет или удаляет случайную команду в случайном списке, а также с
небольшой вероятностью добавляет или удаляет переменную. Количество возможных
команд из-за их простоты небольшое. Правила генерируются для всех возможных
условий, которых не так много из-за небольшого количества проверок.

Смешивание просто объединяет переменные и случайно выбирая половину правил из
«родителей», формирует новую программу.

Код программы $D^2NA$ представляется из себя обычный текст и очень похож на
современные языки программирования. Его легко понять понять разработчику,
и к нему легко применять множество инструментов для анализа текста (например,
смотреть различия с помощью UNIX-программы \texttt{diff}).

\section{Архитектура генератора}

Инструментарий для $D^2NA$ состоит из двух пакетов:
\begin{itemize}
  \item виртуальной машины \texttt{d2na/vm} для запуска уже готовых программ на
        $D^2NA$;
  \item генератора \texttt{d2na/evolution}, который с помощью генетических
        алгоритмов создаёт новую программу на $D^2NA$;
\end{itemize}

Такой ход позволит упростить разделение разработки программы и её использования.
Например, на сервер, где программа на $D^2NA$ будет выполняться можно поставить
только виртуальную машину, а на компьютер разработчика, который будет задавать
оценочную функцию и следить за ходом генерации, нужно поставить и генератор и
виртуальную машину.

\subsection{Виртуальная машина}

Виртуальная машина \texttt{d2na-vm} выполняет код на языке $D^2NA$ и позволяет
ему общаться с внешним миром с помощью входящих/исходящих сигналов.

Код на языке $D^2NA$ можно выполнять двумя способами:
\begin{itemize}
  \item независимой программой, передав ей файл с $D^2NA$-кодом;
  \item библиотекой для запуска $D^2NA$-кода внутри другого приложения на языке
        программирования Ruby;
\end{itemize}

\subsubsection{Программа интерпретатора}

Программа интерпретатора предназначена для работы с $D^2NA$-кодом человеком или
другой программой, написанной не на языке программирования Ruby.

Управлением программой \texttt{d2na-vm} сделано согласно рекомендация для
UNIX:
\begin{itemize}
  \item Программа предназначена для запуска их текстового терминала и общается
        с внешним миром простым текстом.
  \item При запуске можно указать аргументы. Они могут быть либо однобуквенные,
        и перед ними должен быть дефис (например, \texttt{-h}), или полным
        названием команды с двумя дефиса вначале (например, \texttt{-help}).
\end{itemize}

Чтобы вызвать интерпретатор, нужно в текстовом термина набрать команду вида:

\texttt{d2na-vm} опции файл

Опции могут быть:

\begin{itemize}
  \item \texttt{-p} или \texttt{--prompt} — показывать перед исходящими
        сигналами \texttt{>}, а перед входящими \texttt{<}. Это упрощает работу
        с программой оператору человеку.
  \item \texttt{-c} или \texttt{--color} — показывать перед исходящими
        сигналами красную стрелку \texttt{>}, а перед входящими зелёную стрелку
        \texttt{<}. Это упрощает работу с программой оператору человеку, но
        требует поддержки цветного вывода у текстового терминала.
  \item \texttt{-h} или \texttt{--help} — вывести информацию о опциях и способе
        работы с интерпретатором.
\end{itemize}

После запуска интерпретатор загружает переданный ему файл с $D^2NA$-кодом и
сам посылает ему стартовый входящих сигнал \texttt{:Init}. Если загруженная
$D^2NA$-программа посылает исходящий сигнал, он выводит его в стандартный выход
(\texttt{STDOUT}). Исходящие сигналы разделяются переводом строки.

После загрузки интерпретатор ожидает входящих сигналов со стандартного входа
(\texttt{STDIN}), которые должны оканчиваться переводом строки.
Если входящий сигнал начинается с прописной буквы, то интерпретатор сам
делает первую букву заглавной. При поступлении новых входящих сигналов,
\texttt{d2na-vm} отправляет их загруженной программе на $D^2NA$ и выводи её
ответные исходящие сигналы.

Программа перестаёт работать получив со стандартного входа (\texttt{STDIN}) код
\texttt{ETX} об окончании текста. Его можно ввести нажав \texttt{Ctrl+C}.

Рассмотрим пример работы с виртуальной машиной человеком:
\begin{verbatim}
~$ d2na-vm -p ping-pong.d2na
< Print
> Ping
< Print
> Pong
< Print
> Ping
< ^C
~$
\end{verbatim}

С помощью виртуальной машины код на $D^2NA$ может вызывать приложение на любом
языке и платформе. Её надо лишь запустить программу \texttt{d2na-vm}, передав ей
путь к файлу с $D^2NA$-кодом, и передавать/принимать сигналы через текстовый
канал (\texttt{pipe}):

\begin{verbatim}
IO.popen('d2na-vm ping-pong.d2na') do |io|
  io << 'Print'
  io.read #=> "Ping\n"
  io << 'Print'
  io.read #=> "Pong\n"
  io << 'Print'
  io.read #=> "Ping\n"
end
\end{verbatim}

\subsubsection{Библиотека интерпретации}

Хоть программа-интерпретатор и позволяет работать с $D^2NA$-кодом и человеку,
и любой другой программе, но запуск отдельного процесса и взаимодействие с ним
через канал (\texttt{pipe}) — не самый эффективный способ. Тем более, если
$D^2NA$-код должен быть запущен из приложения на языке программирования Ruby,
то интерпретатор загрузит ещё одну виртуальную машину Ruby, что не имеет смысла.

Поскольку при генератор будет очень часто запускать $D^2NA$-код, то было решено
сделать более быстрый способ запуска $D^2NA$-программ из приложений на языке
программирования Ruby.

Для этого был сделан Ruby-класс \texttt{D2NA::Code} с методами:
\begin{itemize}
  \item \texttt{new(\&block)} — загружает $D2NA$-код переданный в переменной
        \texttt{block}.
  \item \texttt{{<}< singal} — послать входящий сигнал из переменной
        \texttt{signal}.
  \item \texttt{listen(*singals, \&block)} — код в переменной \texttt{block} будет
        вызван, когда загруженный код пошлёт исходящий сигнал, содержащийся в
        массиве \texttt{singals}. Если массив \texttt{singals} пустой, то код из
        \texttt{block} будет вызываться при любом исходящем сигнале.
  \item \texttt{delete\_listeners!} — удаляет все коды, добавленные через метод
        \texttt{listen}.
  \item \texttt{reset!} — обнуляет все переменные загруженного кода
        (переводит его в начальное состояние) и удаляет все коды, добавленные
        через метод \texttt{listen}.
\end{itemize}

При получении первого входящего сигнала библиотека сама отправит загруженному
коду стартовый сигнал \texttt{:Init}. После вызова метода \texttt{reset!} и
обнуления переменных стартовый сигнал \texttt{:Init} будет снова послан
автоматически.

Пример работы с библиотекой:
\begin{verbatim}
require 'd2na/vm'

code = D2NA::Code.new do
  on :Init do
    up :ping
  end

  on :Print, :ping do
    send :Ping
    down :ping
    up :pong
  end

  on :Print, :pong do
    send :Pong
    down :pong
    up :ping
  end
end

code.listen { |signal| puts signal }

code << :Print # Выведет Ping
code << :Print # Выведет Pong
code << :Print # Выведет Ping

code.reset!
code.listen { |signal| puts signal }
code << :Print # Выведет Ping
\end{verbatim}

Очень часто программа работающая с $D^2NA$-кодом должна просто складывать
исходящие сигналы в массив. Поэтому в библиотеке есть специальный класс
\texttt{D2NA::Recorder} для этого. Он расширяет класс массива \texttt{Array},
но позволяет в конструкторе передать код, сигналы с которого он будет
записывать:
\begin{verbatim}
require 'd2na/vm'

code = D2NA::Code.new do
  on :Input do
    up :a
  end
  on :Inpit, :a do
    send :Output
  end
end

out = D2NA::Recorder.new(code)

code << :Input
code << :Input
code << :Input
out #=> [:Output, :Output]
\end{verbatim}

\section{Программная реализация}

\subsection{Средства разработки}

Разработка велась на операционной системе Linux, поскольку являясь UNIX-подобной
операционной системой она обладает целым набором полезным инструментов для
разработки и позволяет программировать быстро и эффективно. Поэтому $D^2NA$
разрабатывалась в духе идеологии UNIX.

При разработке использовалась система контроля версий Git, а исходный код с
историей изменения был опубликован на открытом ресурсу
\texttt{http://github.com/ai/d2na} в Интернете.

Для разработки $D^2NA$ требовался язык удовлетворяющий следующим критериям:
\begin{itemize}
  \item \textbf{Скорость разработки}. Сначала нужно написать систему грубо и
        максимально быстро для проверки идеи. А потом, в случае успеха, уже
        можно оптимизировать систему и переписывать критические блоки на языки
        более низкого уровня, такие как C или Java.
  \item \textbf{Гибкость.} Цель $D^2NA$ — создание инструмента для изучения и
        экспериментов с генетическими алгоритмами, поэтому язык и платформа
        должна быть гибкой, чтобы вносить изменения максимально быстро и легко.
  \item \textbf{Свободный синтаксис.} Желательно, чтобы синтаксис языка $D^2NA$ был
        просто подсинтаксисом (DSL, Domain-Specific Language) языка разработки
        генератора, чтобы не писать отдельный интерпретатор.
  \item \textbf{Кроссплатформенностью.} Язык разработки не должен быть привязан к
        определённой операционной системе или интегрированной среде разработки.
        Результат работы должен запускаться на любой из распространённой
        операционной системе (Windows, Mac OS X, Linux) без перекомпиляции.
        Желательно, чтобы разработку можно было вести использую обычный
        текстовой редактор и простой набор скриптов.
  \item \textbf{Автоматическое тестирование.} Поскольку в рамках проекта
        разрабатывался набор утилит (а не конечный продукт с графическим
        интерфейсом пользователя), то лучше всего подходит автоматическое
        тестирование, желательно с применение подхода BDD (Behavior Driven
        Development).
\end{itemize}

Для поставленных задач лучше всего подходил язык Ruby версии 1.9.

\subsection{Язык программирования Ruby}

\subsubsection{Парадигма}

Ruby — полностью объектно-ориентированный язык. В нём все данные являются
объектами, в отличие от многих других языков, где существуют примитивные типы.
Каждая функция — метод. Переменные Ruby содержат не сами объекты, а ссылки на
них. Присваивание — это не передача значения, а копирование ссылки на
объект\cite{ruby}.

Ruby не поддерживает множественное наследование, но вместо него есть мощный
механизм примесей. Все классы (напрямую или через другие классы) выведены из
класса \texttt{Object}, следовательно, любой объект может использовать
определённые в нем методы (например, \texttt{class}, \texttt{to\_s},
\texttt{nil?}). Процедурный стиль также поддерживается, но все глобальные
процедуры неявно являются закрытыми методами класса \texttt{Object}.

Ruby является мультипарадигменным языком: он поддерживает процедурный стиль
(определение функций и переменных вне классов), объектно-ориентированный
(всё — объект), функциональный (анонимные функции, замыкания, возврат значения
всеми инструкциями, возврат функцией последнего вычисленного значения).
Он поддерживает отражение, метапрограммирование, информацию о типах переменных
на стадии выполнения.

Возможности Ruby \cite{ruby}:
\begin{itemize}
  \item Имеет лаконичный и простой синтаксис, частично разработанный под
  \item Позволяет обрабатывать исключения в стиле Java и Python.
  \item Позволяет переопределять операторы, которые на самом деле являются
        методами.
  \item Полностью объектно-ориентированный язык программирования. Все данные в
        Ruby являются объектами в понимании Smalltalk.
        Единственное исключение — управляющие конструкции, которые в Ruby в 
        отличие от Smalltalk не являются объектами. Например, число \texttt{1} —
        это экземпляр класса \texttt{Fixnum}. Также поддерживается добавление 
        методов в класс и даже в конкретный экземпляр во время выполнения
        программы.
  \item Не поддерживает множественное наследование, но вместо него может
        использоваться концепция «примесей», основанная в данном языке на
        механизме модулей.
  \item Содержит автоматический сборщик мусора. Он работает для всех объектов
        Ruby, в том числе для внешних библиотек.
  \item Создавать расширения для Ruby на C очень просто частично из-за
        сборщика мусора, частично из-за несложного и удобного API.
  \item Поддерживает замыкания с полной привязкой к переменным.
  \item Поддерживает блоки кода (код заключается в \texttt{\{ \ldots \}} или 
        \texttt{do \ldots end}). Блоки могут использоваться в методах или
        преобразовываться в замыкания.
  \item Целые переменные в Ruby автоматически конвертируются между типами
        \texttt{Fixnum} (32-разрядные) и \texttt{Bignum} (больше 32 разрядов) в
        зависимости от их значения, что позволяет производить целочисленные
        математические расчёты с бесконечной точностью.
  \item Не требует предварительного объявления переменных, но для интерпретатора
        желательно, чтобы переменным присваивалось пустое значение \texttt{nil}
        (тогда интерпретатор знает, что идентификатор обозначает переменную, а
        не имя метода). Язык использует простые соглашения для обозначения
        области видимости. Пример: просто \texttt{var} — локальная переменная,
        \texttt{@var} — переменная экземпляра (член или поле объекта класса),
        \texttt{@@var} — переменная класса, \texttt{\$var} — глобальная
        переменная.
  \item В Ruby непосредственно в языке реализованы многие шаблоны
        проектирования, так, например, «одиночка» (Singleton) может быть (хотя и
        не обязан) реализован добавлением необходимых методов к одному
        конкретному объекту.
  \item Может динамически загружать расширения, если это позволяет операционная
        система.
  \item Имеет независимую от ОС поддержку невытесняющей многопоточности.
  \item Перенесён на множество платформ. Он разрабатывался на GNU/Linux, но
        работает на многих версиях Unix, DOS, Microsoft Windows (в частности,
        Win32), Mac OS X, BeOS, OS/2 и т. д.
\end{itemize}

\subsubsection{Пример}

В Ruby все классы являются открытыми, поэтому можно расширить стандартные классы
с помощью дополнительных методов. В следующем примере, мы расширим класс
\texttt{Array} методом \texttt{at\_rand}, который будет возвращать случайный
элемент массива, при этом, если массив \emph{n}-размерный, то в результате
\emph{n} обращений к этому методу, каждый элемент вернется единожды. Данный
метод пригодится как внешний итератор для последовательного случайного перебора
элементов массива.

\begin{verbatim}
  class Array
    def at_rand
      @not_picked = self.sort_by { rand } if @not_picked.empty?
      @not_picked.pop
    end
  end  
\end{verbatim}

Следующий пример позволяет значительно упростить добавление методов для высчета
функции и их производных, он будет использоваться для задания функций активации
в программе: 

\begin{verbatim}
module DerivativeFunctions
  def self.create_function(name, function, derivative)
    define_method name do |value|
      y = function.call x
    
      case value
      when :function then y
      when :derivative then derivative.call y
      else
        raise 'Unknown type of function'
      end
    end
  end
end
\end{verbatim}

\subsubsection{Синтаксис}

Ruby выделяет тем, что обладает довольно гибким синтаксисом:
\begin{itemize}
  \item точка с запятой \texttt{;} необязательна, если команды разделены
        переводом строки;
  \item скобки \texttt{()} необязательна после метода, поскольку в Ruby нельзя
        обращаться к свойствам класса без вызова метода.
\end{itemize}

Например следующий код:

\begin{verbatim}
code.method(1, 2);
\end{verbatim}

Равносилен коду:

\begin{verbatim}
code.method 1, 2
\end{verbatim}

Так же Ruby обладает рядом удобных инструментов, упрощающих синтаксис:
\begin{itemize}
  \item Методу в качестве аргументов можно передать не только значения, но и
        другой код, заключив его между \texttt{do end} после вызова метода.
  \item Строка начатая с двоеточки \texttt{:} будет хранится в программе, как
        число (Symbol). При этом, строки с одинаковыми значениями будут иметь
        один номер. В итоге, сравнение и хранение Symbol значительно более
        эффективно. Можно сказать, что Symbol является удобной заменой констант
        и Enum из более низкоуровневых языков программирования.
\end{itemize}

Так что следующий код:
\begin{verbatim}
on(:Init) do
  puts 1
end
\end{verbatim}

Вызывает метод \texttt{on} с двумя аргументами:
\begin{itemize}
  \item Symbol-строкой со значением «Init»;
  \item Кодов, который печатает 1 (\texttt{puts 1}).
\end{itemize}

\subsection{Анализ $D^2NA$}

В итоге, как можно заметить, синтаксис $D^2NA$ — это просто подсинтаксис
(DSL, Domain-Specific Language) языка программирования Ruby.

Рассмотрим программу на $D^2NA$:
\begin{verbatim}
on :Init do
  up :var
end

on :Input, :var do
  send :Output
  down :var
end
\end{verbatim}

В Ruby точка с запятой и скобки после имени метода являются необязательными,
подставим их в пример:
\begin{verbatim}
on(:Init) do
  up(:var);
end;

on(:Input, :var) do
  send(:Output);
  down(:var);
end;
\end{verbatim}

В итоге получается обычный Ruby-код в котором два раза вызывается метод
\texttt{on}:
\begin{enumerate}
  \item В первом случае он получает два аргумента: Symbol-строку «Init» и код,
        в котором выполняется метод \texttt{up} с параметром «var».
  \item Во втором случае метод \texttt{on} получается три аргумента: две
        Symbol-строки «Input» и «var» и код, который вызывает метод
        \texttt{send} с параметром «Output» и \texttt{down} с параметром «var».
\end{enumerate}

\newpage
\begin{thebibliography}{}

  \bibitem{communication}
    Mitri, S., Hubert, J. and Waibel, M. Social Behavior: From Cooperation to
    Language. — Biological Theory. 2008. — с. 99—102

  \bibitem{dilemma}
    Axelrod R. The Evolution of Cooperation. — Basic Books, 1984

  \bibitem{damage}
    Bongard J., Lipson H. Automated Damage Diagnosis and Recovery for Remote
    Robotics. — ICRA04, 2004

  \bibitem{reinforcement}
    Sutton R., Barto A. Reinforcement Learning. — The MIT Press, 2002

  \bibitem{neural}
    Haykin S. Neural Networks: A Comprehensive Foundation. 2nd Edition. — M.: Prentice Hall, 1998

  \bibitem{shalyto}
    Царев Ф.Н., Шалыто А.А. Применение генетического программирования для
    построения автоматов, управляющих системами со сложным поведением. — 2007
  
  \bibitem{ruby}
      Flanagan D., Matsumoto Y. The Ruby Programming Language. — M.: O'Reilly, 2008

\end{thebibliography}

\end{document}

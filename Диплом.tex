\documentclass[russian,utf8]{eskdtext}
\usepackage{eskdplain}

\setcounter{tocdepth}{2}

\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\begin{document}

\tableofcontents

\newpage
\section{Актуальность темы}

\subsection{Авто-написание программы}
Для того, чтобы программа была автоматически написана, разработчик должен
описать требования к ней в виде оценочной функции. К сожалению, для большинства
бытовых задач, написание подходящей оценочной функции сложнее, чем
разработка самой программы.

Но есть области информационных технологий, где создание программы невероятно
сложно, а описание требований к ней — относительно простое:
\begin{itemize}
  \item Программирование сложных систем, состоящих из автономных объектов
        взаимодействующих друг с другом. Например, группировка простых
        спутников. Такие сложные системы очень надёжны (выход одного элемента
        лишь немного уменьшает мощность множества) и эффективны (из-за
        параллельной работы).
  \item Поиск оптимальных стратегий для теории игр, макроэкономики и
        эволюционной биологии.\cite{communication}
\end{itemize}

Поиск решений для данных задач довольно трудоёмок и сейчас слишком похож на
метод проб и ошибок. Например, чтобы найти оптимальную стратегию в Повторяющейся
дилемме заключённого, её автор, Роберт Аксельрод, просто пригласил знакомых
коллег со всего мира предложить своё решение и выбрал лучшее.\cite{dilemma}

Автоматическая разработка программ способна заменить человека в этом сложном,
долгом и не интересном поиске.

Поскольку сложные системы, теория игр, макроэкономика и эволюционная биология
являются очень востребованными областями науки, то и инструмент для них будет
очень актуален.

\subsection{Саморазвитие программы}
В данный момент изменения в алгоритм программы вносит её разработчик. Тогда,
когда это экономически неоправданно или невозможно, алгоритм делают зависимым
от констант и конечные пользователи или автоматика меняют эти настройки.

Однако, параметры статически заданного алгоритма не могут дать полную гибкость,
что бывает нередко нужно. Например, спамеры постоянно экспериментируют и нередко
обходят защиту спам-фильтров, в итоге программистам снова приходится
анализировать новые методы массовой рекламы и переписывать алгоритмы защиты.

Саморазвитие программ будет очень актуально для:
\begin{itemize}
  \item Защиты от спама, чтобы автоматически подстраиваться под новые уловки,
        когда пользователь отмечает письмо как рекламное.
  \item Алгоритмов противника в компьютерных играх, чтобы подстраиваться под
        способности и навыки игрока.
  \item Автоматических роботов, чтобы изменять программу управления при
        поломках и других непредвиденных ситуациях.\cite{damage} Это особенно
        полезно в областях, где человек не может прийти ему на помощь, а связь
        затрудненна, например, в космосе.
\end{itemize}

\section{Постановка задачи}
Разработчик формулирует требование к алгоритму $a$ в виде оценочной
функции $T$, так чтобы более подходящий для задачи алгоритм давал больший
результат $T(a)$. Разработчик также предоставляет функцию останова $F$, такую,
что $F(T(a))$ вернёт 1, если алгоритм $a$ полностью подходит и цель разработки
достигнута.

Цель данной работы, предоставить инструментарий для разработчика, реализующий
операцию $G(T, F) = a$, которая генерирует алгоритм $a$, получающий максимальное
значение в оценочной функции $T$ и удовлетворяющий критерию останова $F$.

Инструментарий будет использоваться для изучения генетических алгоритмов, так
что важно, чтобы итоговый алгоритм был понятен человеку и весь процесс его
генерации можно было наглядно представить и проанализировать.

\section{Генетические алгоритмы}
Как мы видим, задача сводится к оптимизации функции $T(a)$. Однако характер этой
функции неизвестен. Для подобных задач оптимизации весьма эффективны
генетические алгоритмы.\cite{reinforcement}

Генетический алгоритм $G_{ga}$ работает сразу с множеством кандидатов на решение
(популяцией) $A = [a_1, a_2, …, a_n]$. Это итерационный процесс и каждый шаг
$A_i = G_{ga}(A_{i-1})$ немного улучшает оценочную функцию (за значение
оценочной функции популяции, принимается оценочная функция лучшего члена
популяции).

Каждая итерация $G_{ga}(A) = S(Mi(Mu(R(A))))$ состоит из
операций:\cite{reinforcement}
\begin{enumerate}
  \item Размножения $R(A)$ — увеличения популяции простым копированием.
        Поскольку последующий отбор уменьшит популяцию, размножение поддерживает
        её размер на каждом шаге.
  \item Мутации $Mu(A)$ — случайного изменения элементов.
  \item Смешивания $Mi(A)$ — объединения двух элементов со случайным выбором
        частей из каждой половины.
  \item Отбора $S(A)$ — удаление наименее подходящих кандидатов: для каждого
        элемента популяции вычисляется оценочная функция и элементы с
        наименьшим её значением изымаются из множества.
\end{enumerate}

В конце каждой итерации с помощью функции останова $F(A)$, которую задаёт
разработчик, определяется нужно ли остановить цикл.

\section{Анализ проблемы}
В данным момент, при создании программы, разработчики представляют алгоритм в
виде иерархического дерева команд на одном из множества языков программирования.
Компилятор транслирует исходный текст в машинный код — список команд с условными
переходами.

К сожалению, необходимые для генетического алгоритма мутация и смешивание очень
трудоёмко реализовать для типа данных в виде дерева или списка с переходами.
Поскольку современные языки программирования и машинных код — это не
единственный способ представить алгоритм, то выгоднее представить его в другом,
более эффективном для задачи виде.

\section{Обзор имеющихся решений}

\subsection{Нейронная сеть}
В исследованиях эволюции\cite{communication} довольно часто поведение объекта 
кодируют с помощью нейронной сети:\cite{neural}
\begin{itemize}
  \item Обработка происходит в множестве простых элементов, нейронов.
  \item Сигналы передаются между нейронами через связи.
  \item Каждая связь характеризуется весом, в зависимости от знака которой
        передаваемый сигнал увеличивается или уменьшается.
  \item Каждому нейрону соответствует активационная функция, которая определяет 
        зависимость выходного сигнала от комбинации входящих сигналов.
\end{itemize}

Несмотря на то, что элементы нейронной сети имеют очень ограниченные
вычислительные способности, вся сеть в целом, объединяя большое число таких
элементов, оказывается способной выполнять весьма сложные задачи.

Нейронная сеть представляется в виде матрицы весов $X$, так что элемент
$x_{ij}$ соответствует весу связи от нейрона $i$ к нейрону $j$. Мутация
вносит случайные изменения в веса и, с небольшой вероятностью, добавляет или
удаляет новый нейрон. Смешивание либо усредняет веса между двумя матрицами, либо
случайным образом выбирает ячейки из матриц-«родителей».

К сожалению, человек не может понять алгоритм нейронной сети при беглом взгляде
на матрицу или граф, что требуется в поставленной задаче.

\subsection{Конечные автоматы}
В рамках развития идей А. А. Шалыто о автоматном программировании
рассматривается генерация конечного автомата с помощью генетических
алгоритмов.\cite{shalyto}

Конечный автомат характеризуется множеством состояний и матрицей переходов $X$,
где $x_{ji}$ содержит дискретный код условия при котором автомат перейдёт из
состояний $i$ в состояние $j$.

Матрица состояний преобразуется в битовую строку, с которой генетический
алгоритм и работает: мутация случайно изменяет биты, смешивание объединяет две
строки в одну, случайно выбрав символы из каждой.

К сожалению, для поставленной задачи автоматы имеют ряд недостатков:
\begin{itemize}
  \item Они не полны по Тьюрингу, что несколько ограничивает их гибкость.
  \item Чтобы быть понятными разработчику их надо представить в виде графа, а
        работа с графикой сложнее, чем с обычным текстом.
\end{itemize}

\section{Обзор языка $D^2NA$}
В рамках данной работы был создан особый язык программирования $D^2NA$.

Программа на $D^2NA$ с внешним миром общается с помощью входящих и исходящих
сигналов. Они характеризуются только именем и не имеют параметров и
продолжительности. Количество и имена сигналов напрямую зависят от задачи и
задаются разработчиком. Имя сигнала должно начинаться с двоеточия и заглавной
буквы и может состоять из букв, цифр и знака подчёркивания (например,
\texttt{:Input}).

Существует особый сигнал \texttt{:Init}, которые посылается в программу при её
запуске. Он является своего рода конструктором.

Программа может хранить внутреннее состояние в знаковых целочисленных
переменных. Генератор может автоматически добавлять или удалять их. Имя
переменной должно начинаться с двоеточия и прописной буквы и может состоять из
букв, цифр и знака подчёркивания (например, \texttt{:a}).

Программа состоит из списка правил. Правило характеризуется условием выполнения
и списком команд (правило можно представить в виде оператора if). Условие может
быть двух видов: поступление определённого сигнала и значение определённой
переменной больше 0. Поскольку имена сигналов и переменных отличаются и для
них возможна только одна проверка, то условие записывается как \texttt{on} с
последующими именами сигналов или переменных, разделёнными запятыми (например,
\texttt{on~:Input, :a}).

Команды в правиле будут выполнены только если все проверки условия будут
истинными. Команды записываются между \texttt{do} и \texttt{end} и могут быть
трёх видов: послать исходящий сигнал (\texttt{send X}), увеличить
(\texttt{up x}) или уменьшить (\texttt{down x}) значение переменной.

\subsection{Пример программы на $D^2NA$}
\begin{verbatim}
on :Init do
  up :ping
end

on :Print, :ping do
  send :Ping
  down :ping
  up :pong
end

on :Print, :pong do
  send :Pong
  down :pong
  up :ping
end
\end{verbatim}

Данная простая программа посылает поочерёдно \texttt{:Ping} или \texttt{:Pong}
при каждом входящем сигнале \texttt{:Print}. Чтобы помнить, какой сигнал нужно
послать следующим используются две переменные \texttt{:ping} и \texttt{:pong}.

При запуске программы (при системном сигнале \texttt{:Init}) переменная
\texttt{:ping} увеличивается до значения 1. Далее, когда пришёл сигнал
\texttt{:Print} и значение \texttt{:ping} больше нуля, посылается сигнал
\texttt{:Ping}, \texttt{:ping} уменьшается до 0, а \texttt{:pong}, наоборот,
увеличивается до 1.

При сигнале \texttt{:Print} и положительном значении \texttt{:pong}, посылается
сигнал \texttt{:Pong} и происходит обратная процедура.

\subsection{Генерация программы на $D^2NA$}
Программа на $D^2NA$ представляет из себя просто список списков, которые
генетическому алгоритму удобно смешивать и переставлять.

Мутация добавляет или удаляет случайную команду в случайном списке, а также с
небольшой вероятностью добавляет или удаляет переменную. Количество возможных
команд из-за их простоты небольшое. Правила генерируются для всех возможных
условий, которых не так много из-за небольшого количества проверок.

Смешивание просто объединяет переменные и случайно выбирая половину правил из
«родителей», формирует новую программу.

Код программы $D^2NA$ представляется из себя обычный текст и очень похож на
современные языки программирования. Его легко понять понять разработчику,
и к нему легко применять множество инструментов для анализа текста (например,
смотреть различия с помощью UNIX-программы \texttt{diff}).

\section{Программная реализация}

\subsection{Средства разработки}
Для разработки $D^2NA$ требовался язык удовлетворяющий следующим критериям:
\begin{itemize}
  \item {\bf Скорость разработки}. Сначала нужно написать систему грубо и
        максимально быстро для проверки идеи. А потом, в случае успеха, уже
        можно оптимизировать систему и переписывать критические блоки на языки
        более низкого уровня, такие как C или Java.
  \item {\bf Гибкость.} Цель $D^2NA$ — создание инструмента для изучения и
        экспериментов с генетическими алгоритмами, поэтому язык и платформа
        должна быть гибкой, чтобы вносить изменения максимально быстро и легко.
  \item {\bf Свободный синтаксис.} Желательно, чтобы синтаксис языка $D^2NA$ был
        просто подсинтаксисом (DSL, Domain-Specific Language) языка разработки
        генератора, чтобы не писать отдельный интерпретатор.
  \item {\bf Кроссплатформенностью.} Язык разработки не должен быть привязан к
        определённой операционной системе или интегрированной среде разработки.
        Результат работы должен запускаться на любой из распространённой
        операционной системе (Windows, Mac OS X, Linux) без перекомпиляции.
        Желательно, чтобы разработку можно было вести использую обычный
        текстовой редактор и простой набор скриптов.
  \item {\bf Автоматическое тестирование.} Поскольку в рамках проекта
        разрабатывался набор утилит (а не конечный продукт с графическим
        интерфейсом пользователя), то лучше всего подходит автоматическое
        тестирование, желательно с применение подхода BDD (Behavior Driven
        Development).
\end{itemize}

Для поставленных задач лучше всего подходил язык Ruby версии 1.9.

\subsection{Язык программирования Ruby}

\subsubsection{Парадигма}

Ruby — полностью объектно-ориентированный язык. В нём все данные являются
объектами, в отличие от многих других языков, где существуют примитивные типы.
Каждая функция — метод. Переменные Ruby содержат не сами объекты, а ссылки на
них. Присваивание — это не передача значения, а копирование ссылки на
объект\cite{ruby}.

Ruby не поддерживает множественное наследование, но вместо него есть мощный
механизм примесей. Все классы (напрямую или через другие классы) выведены из
класса \texttt{Object}, следовательно, любой объект может использовать
определённые в нем методы (например, \texttt{class}, \texttt{to\_s},
\texttt{nil?}). Процедурный стиль также поддерживается, но все глобальные
процедуры неявно являются закрытыми методами класса \texttt{Object}.

Ruby является мультипарадигменным языком: он поддерживает процедурный стиль
(определение функций и переменных вне классов), объектно-ориентированный
(всё — объект), функциональный (анонимные функции, замыкания, возврат значения
всеми инструкциями, возврат функцией последнего вычисленного значения).
Он поддерживает отражение, метапрограммирование, информацию о типах переменных
на стадии выполнения.

Возможности Ruby \cite{ruby}:
\begin{itemize}
  \item Имеет лаконичный и простой синтаксис, частично разработанный под
  \item Позволяет обрабатывать исключения в стиле Java и Python.
  \item Позволяет переопределять операторы, которые на самом деле являются
        методами.
  \item Полностью объектно-ориентированный язык программирования. Все данные в
        Ruby являются объектами в понимании Smalltalk.
        Единственное исключение — управляющие конструкции, которые в Ruby в 
        отличие от Smalltalk не являются объектами. Например, число \texttt{1} —
        это экземпляр класса \texttt{Fixnum}. Также поддерживается добавление 
        методов в класс и даже в конкретный экземпляр во время выполнения
        программы.
  \item Не поддерживает множественное наследование, но вместо него может
        использоваться концепция «примесей», основанная в данном языке на
        механизме модулей.
  \item Содержит автоматический сборщик мусора. Он работает для всех объектов
        Ruby, в том числе для внешних библиотек.
  \item Создавать расширения для Ruby на C очень просто частично из-за
        сборщика мусора, частично из-за несложного и удобного API.
  \item Поддерживает замыкания с полной привязкой к переменным.
  \item Поддерживает блоки кода (код заключается в \texttt{\{ \ldots \}} или 
        \texttt{do \ldots end}). Блоки могут использоваться в методах или
        преобразовываться в замыкания.
  \item Целые переменные в Ruby автоматически конвертируются между типами
        \texttt{Fixnum} (32-разрядные) и \texttt{Bignum} (больше 32 разрядов) в
        зависимости от их значения, что позволяет производить целочисленные
        математические расчёты с бесконечной точностью.
  \item Не требует предварительного объявления переменных, но для интерпретатора
        желательно, чтобы переменным присваивалось пустое значение \texttt{nil}
        (тогда интерпретатор знает, что идентификатор обозначает переменную, а
        не имя метода). Язык использует простые соглашения для обозначения
        области видимости. Пример: просто \texttt{var} — локальная переменная,
        \texttt{@var} — переменная экземпляра (член или поле объекта класса),
        \texttt{@@var} — переменная класса, \texttt{\$var} — глобальная
        переменная.
  \item В Ruby непосредственно в языке реализованы многие шаблоны
        проектирования, так, например, «одиночка» (Singleton) может быть (хотя и
        не обязан) реализован добавлением необходимых методов к одному
        конкретному объекту.
  \item Может динамически загружать расширения, если это позволяет операционная
        система.
  \item Имеет независимую от ОС поддержку невытесняющей многопоточности.
  \item Перенесён на множество платформ. Он разрабатывался на GNU/Linux, но
        работает на многих версиях Unix, DOS, Microsoft Windows (в частности,
        Win32), Mac OS X, BeOS, OS/2 и т. д.
\end{itemize}

\subsubsection{Пример}
В Ruby все классы являются открытыми, поэтому можно расширить стандартные классы
с помощью дополнительных методов. В следующем примере, мы расширим класс
\texttt{Array} методом \texttt{at\_rand}, который будет возвращать случайный
элемент массива, при этом, если массив \emph{n}-размерный, то в результате
\emph{n} обращений к этому методу, каждый элемент вернется единожды. Данный
метод пригодится как внешний итератор для последовательного случайного перебора
элементов массива.

\begin{verbatim}
  class Array
    def at_rand
      @not_picked = self.sort_by { rand } if @not_picked.empty?
      @not_picked.pop
    end
  end  
\end{verbatim}

Следующий пример позволяет значительно упростить добавление методов для высчета
функции и их производных, он будет использоваться для задания функций активации
в программе: 

\begin{verbatim}
module DerivativeFunctions
  def self.create_function(name, function, derivative)
    define_method name do |value|
      y = function.call x
    
      case value
      when :function then y
      when :derivative then derivative.call y
      else
        raise 'Unknown type of function'
      end
    end
  end
end
\end{verbatim}

\newpage
\begin{thebibliography}{}

  \bibitem{communication}
    Mitri, S., Hubert, J. and Waibel, M. Social Behavior: From Cooperation to
    Language. — Biological Theory. 2008. — с. 99—102

  \bibitem{dilemma}
    Axelrod R. The Evolution of Cooperation. — Basic Books, 1984

  \bibitem{damage}
    Bongard J., Lipson H. Automated Damage Diagnosis and Recovery for Remote
    Robotics. — ICRA04, 2004

  \bibitem{reinforcement}
    Sutton R., Barto A. Reinforcement Learning. — The MIT Press, 2002

  \bibitem{neural}
    Haykin S. Neural Networks: A Comprehensive Foundation. 2nd Edition. — M.: Prentice Hall, 1998

  \bibitem{shalyto}
    Царев Ф.Н., Шалыто А.А. Применение генетического программирования для
    построения автоматов, управляющих системами со сложным поведением. — 2007
  
  \bibitem{ruby}
      Flanagan D., Matsumoto Y. The Ruby Programming Language. — M.: O'Reilly, 2008

\end{thebibliography}

\end{document}
